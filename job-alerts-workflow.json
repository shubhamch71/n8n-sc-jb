{
  "name": "DevOps Entry-Level Job Alerts (Dynamic)",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "hours",
              "hoursInterval": 2
            }
          ]
        }
      },
      "id": "trigger-cron",
      "name": "Bi-Hourly Trigger",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [0, 400]
    },
    {
      "parameters": {
        "jsCode": "// =============================================================================\n// SOURCE CONFIGURATION - EDIT THIS SECTION TO ADD/REMOVE SOURCES\n// =============================================================================\n// FILTER VERSION - Track which filter version was used\nconst FILTER_VERSION = 'v1.0';\n\nconst staticData = $getWorkflowStaticData('global');\n\n// Store filter version for this run\nstaticData.filterVersion = FILTER_VERSION;\n\n// Check if sources are already configured in static data\nif (!staticData.sources || staticData.sources.length === 0) {\n  // Default source configuration - modify this list as needed\n  staticData.sources = [\n    // ===== GREENHOUSE COMPANIES =====\n    { ats: 'greenhouse', board: 'hashicorp', company: 'HashiCorp', enabled: true },\n    { ats: 'greenhouse', board: 'gitlab', company: 'GitLab', enabled: true },\n    { ats: 'greenhouse', board: 'cloudflare', company: 'Cloudflare', enabled: true },\n    { ats: 'greenhouse', board: 'datadog', company: 'Datadog', enabled: true },\n    { ats: 'greenhouse', board: 'mongodb', company: 'MongoDB', enabled: true },\n    { ats: 'greenhouse', board: 'elastic', company: 'Elastic', enabled: true },\n    { ats: 'greenhouse', board: 'grafana', company: 'Grafana Labs', enabled: true },\n    { ats: 'greenhouse', board: 'cockroachlabs', company: 'CockroachDB', enabled: true },\n    { ats: 'greenhouse', board: 'stripe', company: 'Stripe', enabled: true },\n    { ats: 'greenhouse', board: 'databricks', company: 'Databricks', enabled: true },\n    \n    // ===== LEVER COMPANIES =====\n    { ats: 'lever', board: 'twilio', company: 'Twilio', enabled: true },\n    { ats: 'lever', board: 'figma', company: 'Figma', enabled: true },\n    { ats: 'lever', board: 'netflix', company: 'Netflix', enabled: true },\n    { ats: 'lever', board: 'discord', company: 'Discord', enabled: true },\n    { ats: 'lever', board: 'notion', company: 'Notion', enabled: true },\n    { ats: 'lever', board: 'vercel', company: 'Vercel', enabled: true },\n    { ats: 'lever', board: 'supabase', company: 'Supabase', enabled: true },\n    \n    // ===== ASHBY COMPANIES =====\n    { ats: 'ashby', board: 'ramp', company: 'Ramp', enabled: true },\n    { ats: 'ashby', board: 'notion', company: 'Notion (Ashby)', enabled: true },\n    { ats: 'ashby', board: 'plaid', company: 'Plaid', enabled: true },\n    \n    // ===== SMARTRECRUITERS COMPANIES =====\n    { ats: 'smartrecruiters', board: 'Visa', company: 'Visa', enabled: true },\n    { ats: 'smartrecruiters', board: 'BOSCH', company: 'Bosch', enabled: true },\n    \n    // ===== WORKABLE COMPANIES =====\n    { ats: 'workable', board: 'deel', company: 'Deel', enabled: true },\n    \n    // ===== REMOTEOK TAGS =====\n    { ats: 'remoteok', tag: 'devops', company: 'RemoteOK', enabled: true },\n    { ats: 'remoteok', tag: 'cloud', company: 'RemoteOK', enabled: true },\n    { ats: 'remoteok', tag: 'sre', company: 'RemoteOK', enabled: true },\n    { ats: 'remoteok', tag: 'kubernetes', company: 'RemoteOK', enabled: true },\n    \n    // ===== LINKEDIN (LOW FREQUENCY FALLBACK) =====\n    { ats: 'linkedin', keywords: 'devops entry level', company: 'LinkedIn', enabled: false }\n  ];\n}\n\n// Merge in discovered companies from Company Discovery workflow\nif (staticData.companyList && staticData.companyList.length > 0) {\n  const existingBoards = new Set(staticData.sources.map(s => s.board?.toLowerCase()));\n  for (const company of staticData.companyList) {\n    if (company.enabled && company.ats && company.board) {\n      const boardLower = company.board.toLowerCase();\n      if (!existingBoards.has(boardLower)) {\n        existingBoards.add(boardLower);\n        staticData.sources.push({\n          ats: company.ats,\n          board: company.board,\n          company: company.company,\n          enabled: true,\n          discovered: true\n        });\n      }\n    }\n  }\n}\n\n// Filter to only enabled sources\nconst enabledSources = staticData.sources.filter(s => s.enabled !== false);\n\n// User agents for rotation\nconst userAgents = [\n  'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36',\n  'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36',\n  'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36',\n  'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:123.0) Gecko/20100101 Firefox/123.0',\n  'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Safari/605.1.15'\n];\n\n// Prepare sources with metadata - these are Layer A (Direct ATS)\nconst preparedSources = enabledSources.map((source, index) => ({\n  ...source,\n  sourceIndex: index,\n  userAgent: userAgents[index % userAgents.length],\n  waitTime: Math.floor(Math.random() * 30000) + 10000,\n  discovery_layer: 'direct_ats',\n  discovered_via: source.ats\n}));\n\n// Initialize job collection for this run\nstaticData.collectedJobs = [];\nstaticData.sourceErrors = [];\n\n// Track run stats for health monitoring\nstaticData.lastRunTime = new Date().toISOString();\nif (!staticData.runStats) {\n  staticData.runStats = { jobsLast24h: 0, lastHeartbeat: null };\n}\n\nconsole.log(`[${FILTER_VERSION}] Loaded ${preparedSources.length} enabled sources`);\n\nreturn preparedSources.map(source => ({ json: source }));"
      },
      "id": "load-sources",
      "name": "Load Source Configuration",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [220, 400]
    },
    {
      "parameters": {
        "batchSize": 1,
        "options": {}
      },
      "id": "iterate-sources",
      "name": "Iterate Sources",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [440, 400]
    },
    {
      "parameters": {
        "amount": "={{ $json.waitTime }}",
        "unit": "milliseconds"
      },
      "id": "rate-limit-wait",
      "name": "Rate Limit Wait",
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [660, 400]
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": false,
                  "leftValue": "",
                  "typeValidation": "loose"
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.ats }}",
                    "rightValue": "greenhouse",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "greenhouse"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": false,
                  "leftValue": "",
                  "typeValidation": "loose"
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.ats }}",
                    "rightValue": "lever",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "lever"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": false,
                  "leftValue": "",
                  "typeValidation": "loose"
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.ats }}",
                    "rightValue": "ashby",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "ashby"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": false,
                  "leftValue": "",
                  "typeValidation": "loose"
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.ats }}",
                    "rightValue": "smartrecruiters",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "smartrecruiters"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": false,
                  "leftValue": "",
                  "typeValidation": "loose"
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.ats }}",
                    "rightValue": "workable",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "workable"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": false,
                  "leftValue": "",
                  "typeValidation": "loose"
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.ats }}",
                    "rightValue": "remoteok",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "remoteok"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "id": "route-by-ats",
      "name": "Route by ATS Type",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3,
      "position": [880, 400]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "=https://boards-api.greenhouse.io/v1/boards/{{ $json.board }}/jobs",
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          },
          "timeout": 30000
        },
        "headerParameters": {
          "parameters": [
            {
              "name": "User-Agent",
              "value": "={{ $json.userAgent }}"
            },
            {
              "name": "Accept",
              "value": "application/json"
            }
          ]
        }
      },
      "id": "handler-greenhouse",
      "name": "Greenhouse Handler",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1100, 0],
      "continueOnFail": true
    },
    {
      "parameters": {
        "method": "GET",
        "url": "=https://api.lever.co/v0/postings/{{ $json.board }}?mode=json",
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          },
          "timeout": 30000
        },
        "headerParameters": {
          "parameters": [
            {
              "name": "User-Agent",
              "value": "={{ $json.userAgent }}"
            },
            {
              "name": "Accept",
              "value": "application/json"
            }
          ]
        }
      },
      "id": "handler-lever",
      "name": "Lever Handler",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1100, 200],
      "continueOnFail": true
    },
    {
      "parameters": {
        "method": "GET",
        "url": "=https://api.ashbyhq.com/posting-api/job-board/{{ $json.board }}",
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          },
          "timeout": 30000
        },
        "headerParameters": {
          "parameters": [
            {
              "name": "User-Agent",
              "value": "={{ $json.userAgent }}"
            },
            {
              "name": "Accept",
              "value": "application/json"
            }
          ]
        }
      },
      "id": "handler-ashby",
      "name": "Ashby Handler",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1100, 400],
      "continueOnFail": true
    },
    {
      "parameters": {
        "method": "GET",
        "url": "=https://api.smartrecruiters.com/v1/companies/{{ $json.board }}/postings",
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          },
          "timeout": 30000
        },
        "headerParameters": {
          "parameters": [
            {
              "name": "User-Agent",
              "value": "={{ $json.userAgent }}"
            },
            {
              "name": "Accept",
              "value": "application/json"
            }
          ]
        }
      },
      "id": "handler-smartrecruiters",
      "name": "SmartRecruiters Handler",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1100, 600],
      "continueOnFail": true
    },
    {
      "parameters": {
        "method": "GET",
        "url": "=https://apply.workable.com/api/v1/widget/accounts/{{ $json.board }}",
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          },
          "timeout": 30000
        },
        "headerParameters": {
          "parameters": [
            {
              "name": "User-Agent",
              "value": "={{ $json.userAgent }}"
            },
            {
              "name": "Accept",
              "value": "application/json"
            }
          ]
        }
      },
      "id": "handler-workable",
      "name": "Workable Handler",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1100, 800],
      "continueOnFail": true
    },
    {
      "parameters": {
        "method": "GET",
        "url": "=https://remoteok.com/api?tag={{ $json.tag }}",
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          },
          "timeout": 30000
        },
        "headerParameters": {
          "parameters": [
            {
              "name": "User-Agent",
              "value": "={{ $json.userAgent }}"
            },
            {
              "name": "Accept",
              "value": "application/json"
            }
          ]
        }
      },
      "id": "handler-remoteok",
      "name": "RemoteOK Handler",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1100, 1000],
      "continueOnFail": true
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// =============================================================================\n// GREENHOUSE PARSER - Generic handler for all Greenhouse boards\n// =============================================================================\nconst sourceConfig = $('Route by ATS Type').first().json;\nconst data = $input.item.json;\nconst jobs = [];\nconst staticData = $getWorkflowStaticData('global');\n\ntry {\n  if (data.jobs && Array.isArray(data.jobs)) {\n    const companyName = data.name || sourceConfig.company || 'Unknown';\n    \n    for (const job of data.jobs) {\n      jobs.push({\n        job_title: (job.title || '').trim(),\n        company: companyName,\n        location: (job.location?.name || job.offices?.[0]?.name || 'Unknown').trim(),\n        job_url: job.absolute_url || `https://boards.greenhouse.io/${sourceConfig.board}/jobs/${job.id}`,\n        source: 'Greenhouse',\n        ats: 'greenhouse',\n        board: sourceConfig.board,\n        description: '',\n        posted_at: job.updated_at || new Date().toISOString(),\n        job_id: job.id?.toString() || '',\n        discovery_layer: sourceConfig.discovery_layer || 'direct_ats',\n        discovered_via: sourceConfig.discovered_via || 'greenhouse',\n        filter_version: staticData.filterVersion || 'v1.0'\n      });\n    }\n  }\n} catch (err) {\n  console.log(`Greenhouse parse error for ${sourceConfig.board}: ${err.message}`);\n}\n\nreturn { json: { jobs, source: sourceConfig, count: jobs.length } };"
      },
      "id": "parse-greenhouse",
      "name": "Parse Greenhouse",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1320, 0],
      "continueOnFail": true
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// =============================================================================\n// LEVER PARSER - Generic handler for all Lever boards\n// =============================================================================\nconst sourceConfig = $('Route by ATS Type').first().json;\nconst data = $input.item.json;\nconst jobs = [];\nconst staticData = $getWorkflowStaticData('global');\n\ntry {\n  if (Array.isArray(data)) {\n    for (const job of data) {\n      if (job.hostedUrl || job.applyUrl) {\n        jobs.push({\n          job_title: (job.text || job.title || '').trim(),\n          company: sourceConfig.company || job.categories?.team || 'Unknown',\n          location: (job.categories?.location || job.workplaceType || 'Unknown').trim(),\n          job_url: job.hostedUrl || job.applyUrl || '',\n          source: 'Lever',\n          ats: 'lever',\n          board: sourceConfig.board,\n          description: (job.descriptionPlain || job.description || '').toLowerCase().substring(0, 1000),\n          posted_at: job.createdAt ? new Date(job.createdAt).toISOString() : new Date().toISOString(),\n          job_id: job.id || '',\n          discovery_layer: sourceConfig.discovery_layer || 'direct_ats',\n          discovered_via: sourceConfig.discovered_via || 'lever',\n          filter_version: staticData.filterVersion || 'v1.0'\n        });\n      }\n    }\n  }\n} catch (err) {\n  console.log(`Lever parse error for ${sourceConfig.board}: ${err.message}`);\n}\n\nreturn { json: { jobs, source: sourceConfig, count: jobs.length } };"
      },
      "id": "parse-lever",
      "name": "Parse Lever",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1320, 200],
      "continueOnFail": true
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// =============================================================================\n// ASHBY PARSER - Generic handler for all Ashby boards\n// =============================================================================\nconst sourceConfig = $('Route by ATS Type').first().json;\nconst data = $input.item.json;\nconst jobs = [];\nconst staticData = $getWorkflowStaticData('global');\n\ntry {\n  const jobList = data.jobs || data.data || [];\n  \n  if (Array.isArray(jobList)) {\n    for (const job of jobList) {\n      jobs.push({\n        job_title: (job.title || job.name || '').trim(),\n        company: sourceConfig.company || job.organizationName || 'Unknown',\n        location: (job.location || job.locationName || job.address?.city || 'Unknown').trim(),\n        job_url: job.jobUrl || job.applicationUrl || `https://jobs.ashbyhq.com/${sourceConfig.board}/${job.id}`,\n        source: 'Ashby',\n        ats: 'ashby',\n        board: sourceConfig.board,\n        description: (job.descriptionPlain || job.description || '').toLowerCase().substring(0, 1000),\n        posted_at: job.publishedAt || job.createdAt || new Date().toISOString(),\n        job_id: job.id || '',\n        discovery_layer: sourceConfig.discovery_layer || 'direct_ats',\n        discovered_via: sourceConfig.discovered_via || 'ashby',\n        filter_version: staticData.filterVersion || 'v1.0'\n      });\n    }\n  }\n} catch (err) {\n  console.log(`Ashby parse error for ${sourceConfig.board}: ${err.message}`);\n}\n\nreturn { json: { jobs, source: sourceConfig, count: jobs.length } };"
      },
      "id": "parse-ashby",
      "name": "Parse Ashby",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1320, 400],
      "continueOnFail": true
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// =============================================================================\n// SMARTRECRUITERS PARSER - Generic handler for all SmartRecruiters boards\n// =============================================================================\nconst sourceConfig = $('Route by ATS Type').first().json;\nconst data = $input.item.json;\nconst jobs = [];\nconst staticData = $getWorkflowStaticData('global');\n\ntry {\n  const jobList = data.content || data.jobs || data.results || [];\n  \n  if (Array.isArray(jobList)) {\n    for (const job of jobList) {\n      const location = job.location || {};\n      const locationStr = [location.city, location.region, location.country]\n        .filter(Boolean).join(', ') || 'Unknown';\n      \n      jobs.push({\n        job_title: (job.name || job.title || '').trim(),\n        company: sourceConfig.company || job.company?.name || 'Unknown',\n        location: locationStr.trim(),\n        job_url: job.applyUrl || job.ref || `https://jobs.smartrecruiters.com/${sourceConfig.board}/${job.id}`,\n        source: 'SmartRecruiters',\n        ats: 'smartrecruiters',\n        board: sourceConfig.board,\n        description: (job.jobAd?.sections?.jobDescription?.text || '').toLowerCase().substring(0, 1000),\n        posted_at: job.releasedDate || job.createdOn || new Date().toISOString(),\n        job_id: job.id || job.uuid || '',\n        discovery_layer: sourceConfig.discovery_layer || 'direct_ats',\n        discovered_via: sourceConfig.discovered_via || 'smartrecruiters',\n        filter_version: staticData.filterVersion || 'v1.0'\n      });\n    }\n  }\n} catch (err) {\n  console.log(`SmartRecruiters parse error for ${sourceConfig.board}: ${err.message}`);\n}\n\nreturn { json: { jobs, source: sourceConfig, count: jobs.length } };"
      },
      "id": "parse-smartrecruiters",
      "name": "Parse SmartRecruiters",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1320, 600],
      "continueOnFail": true
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// =============================================================================\n// WORKABLE PARSER - Generic handler for all Workable boards\n// =============================================================================\nconst sourceConfig = $('Route by ATS Type').first().json;\nconst data = $input.item.json;\nconst jobs = [];\nconst staticData = $getWorkflowStaticData('global');\n\ntry {\n  const jobList = data.jobs || data.results || [];\n  \n  if (Array.isArray(jobList)) {\n    for (const job of jobList) {\n      jobs.push({\n        job_title: (job.title || job.name || '').trim(),\n        company: sourceConfig.company || data.name || 'Unknown',\n        location: (job.location || job.city || 'Unknown').trim(),\n        job_url: job.url || job.application_url || `https://apply.workable.com/${sourceConfig.board}/j/${job.shortcode}`,\n        source: 'Workable',\n        ats: 'workable',\n        board: sourceConfig.board,\n        description: (job.description || '').toLowerCase().substring(0, 1000),\n        posted_at: job.published_on || job.created_at || new Date().toISOString(),\n        job_id: job.shortcode || job.id || '',\n        discovery_layer: sourceConfig.discovery_layer || 'direct_ats',\n        discovered_via: sourceConfig.discovered_via || 'workable',\n        filter_version: staticData.filterVersion || 'v1.0'\n      });\n    }\n  }\n} catch (err) {\n  console.log(`Workable parse error for ${sourceConfig.board}: ${err.message}`);\n}\n\nreturn { json: { jobs, source: sourceConfig, count: jobs.length } };"
      },
      "id": "parse-workable",
      "name": "Parse Workable",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1320, 800],
      "continueOnFail": true
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// =============================================================================\n// REMOTEOK PARSER - Generic handler for all RemoteOK tags\n// =============================================================================\nconst sourceConfig = $('Route by ATS Type').first().json;\nconst data = $input.item.json;\nconst jobs = [];\nconst staticData = $getWorkflowStaticData('global');\n\ntry {\n  if (Array.isArray(data) && data.length > 0) {\n    // First item is usually metadata, skip it if it has 'legal' property\n    const startIdx = data[0]?.legal ? 1 : 0;\n    \n    for (let i = startIdx; i < data.length; i++) {\n      const job = data[i];\n      if (job.position && job.company) {\n        jobs.push({\n          job_title: (job.position || '').trim(),\n          company: (job.company || '').trim(),\n          location: (job.location || 'Remote').trim(),\n          job_url: job.url || `https://remoteok.com/remote-jobs/${job.id}`,\n          source: 'RemoteOK',\n          ats: 'remoteok',\n          board: sourceConfig.tag,\n          description: (job.description || '').toLowerCase().substring(0, 1000),\n          posted_at: job.date || new Date().toISOString(),\n          job_id: job.id?.toString() || '',\n          tags: job.tags || [],\n          discovery_layer: sourceConfig.discovery_layer || 'direct_ats',\n          discovered_via: sourceConfig.discovered_via || 'remoteok',\n          filter_version: staticData.filterVersion || 'v1.0'\n        });\n      }\n    }\n  }\n} catch (err) {\n  console.log(`RemoteOK parse error for tag ${sourceConfig.tag}: ${err.message}`);\n}\n\nreturn { json: { jobs, source: sourceConfig, count: jobs.length } };"
      },
      "id": "parse-remoteok",
      "name": "Parse RemoteOK",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1320, 1000],
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// =============================================================================\n// FALLBACK HANDLER - For unsupported ATS types\n// =============================================================================\nconst sourceConfig = $input.first().json;\n\nconsole.log(`Unsupported ATS type: ${sourceConfig.ats} for ${sourceConfig.company}`);\n\n// Log the error for monitoring\nconst staticData = $getWorkflowStaticData('global');\nstaticData.sourceErrors.push({\n  source: sourceConfig,\n  error: `Unsupported ATS type: ${sourceConfig.ats}`,\n  timestamp: new Date().toISOString()\n});\n\nreturn [{ json: { jobs: [], source: sourceConfig, count: 0, error: 'unsupported_ats' } }];"
      },
      "id": "handler-fallback",
      "name": "Unsupported ATS Handler",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1320, 1200],
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// =============================================================================\n// COLLECT JOBS - Accumulate jobs from current source into static data\n// =============================================================================\nconst staticData = $getWorkflowStaticData('global');\nconst result = $input.first().json;\n\nif (result.jobs && Array.isArray(result.jobs)) {\n  staticData.collectedJobs.push(...result.jobs);\n  console.log(`Collected ${result.jobs.length} jobs from ${result.source?.company || 'unknown'} (${result.source?.ats || 'unknown'})`);\n}\n\nif (result.error) {\n  staticData.sourceErrors.push({\n    source: result.source,\n    error: result.error,\n    timestamp: new Date().toISOString()\n  });\n}\n\nreturn [{ json: { \n  collected: staticData.collectedJobs.length,\n  sourceProcessed: result.source?.company || 'unknown'\n} }];"
      },
      "id": "collect-jobs",
      "name": "Collect Jobs",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1540, 400]
    },
    {
      "parameters": {
        "jsCode": "// =============================================================================\n// FILTER JOBS - Apply all filtering rules\n// =============================================================================\nconst staticData = $getWorkflowStaticData('global');\nconst allJobs = staticData.collectedJobs || [];\n\n// Clear collection for next run\nstaticData.collectedJobs = [];\n\nconsole.log(`Processing ${allJobs.length} total jobs`);\n\n// =============================================================================\n// FILTERING CONFIGURATION - Customize these arrays as needed\n// =============================================================================\nconst config = {\n  // Keywords that indicate relevant DevOps/Cloud/Platform roles\n  relevantKeywords: [\n    'devops', 'cloud engineer', 'platform engineer', 'kubernetes', 'k8s',\n    'mlops', 'aiops', 'llmops', 'cloud infrastructure', 'ml infrastructure',\n    'ai platform', 'cloud platform', 'site reliability', 'sre', 'infrastructure',\n    'cloud operations', 'devsecops', 'gitops', 'cloud native', 'container',\n    'aws engineer', 'azure engineer', 'gcp engineer'\n  ],\n  \n  // Strong positive signals in title or description\n  positiveSignals: [\n    'kubernetes', 'k8s', 'docker', 'aws', 'gcp', 'azure', 'terraform',\n    'ansible', 'ci/cd', 'cicd', 'jenkins', 'gitlab', 'github actions', 'argocd',\n    'gitops', 'helm', 'linux', 'cloud native', 'infrastructure as code',\n    'iac', 'prometheus', 'grafana', 'datadog', 'cloudformation', 'pulumi',\n    'kubeflow', 'mlflow', 'sagemaker', 'vertex ai', 'ray', 'airflow',\n    'eks', 'gke', 'aks', 'openshift', 'rancher'\n  ],\n  \n  // Indicators of junior/entry-level positions\n  juniorIndicators: [\n    'junior', 'entry level', 'entry-level', 'associate', 'graduate',\n    'trainee', 'intern', 'internship', 'new grad', 'early career',\n    '0-1 year', '0-2 year', '1-2 year', '1-3 year', '2 year', '2-3 year',\n    '0–1 year', '0–2 year', '1–2 year', '1–3 year', '2–3 year',\n    'fresher', 'beginner', 'no experience required', 'recent graduate',\n    'new college', 'university grad', 'i ', 'ii ', ' i', ' ii',\n    'level 1', 'level 2', 'tier 1', 'tier 2'\n  ],\n  \n  // Seniority indicators to EXCLUDE from titles\n  seniorExclusions: [\n    'senior', 'staff', 'principal', 'lead', 'manager', 'architect',\n    'director', 'head of', 'vp ', 'vice president', 'chief', 'sr.', 'sr ',\n    'distinguished', 'fellow', 'iii', 'iv', 'level 3', 'level 4', 'level 5'\n  ],\n  \n  // High experience indicators to EXCLUDE from descriptions\n  experienceExclusions: [\n    '4+ year', '5+ year', '6+ year', '7+ year', '8+ year', '10+ year',\n    '4\\\\+ year', '5\\\\+ year', 'extensive experience', 'significant experience',\n    'senior-level', 'senior level', 'seasoned professional', 'deep expertise',\n    '5 years', '6 years', '7 years', '8 years', '10 years',\n    'proven track record', 'expert level'\n  ],\n  \n  // Locations to exclude\n  excludedLocations: ['pakistan', 'bangladesh', 'sri lanka', 'syria'],\n  \n  // Role types to exclude\n  excludedRoles: [\n    'sales', 'marketing', 'hr ', 'human resource', 'recruiter',\n    'customer success', 'account manager', 'business development',\n    'product manager', 'project manager', 'scrum master', 'support engineer',\n    'technical writer', 'content', 'design', 'ux ', 'ui '\n  ]\n};\n\n// =============================================================================\n// FILTERING FUNCTIONS\n// =============================================================================\n\nfunction isRelevantRole(job) {\n  const titleLower = job.job_title.toLowerCase();\n  const descLower = (job.description || '').toLowerCase();\n  \n  // Check if title contains any relevant keywords\n  const hasRelevantTitle = config.relevantKeywords.some(kw => titleLower.includes(kw));\n  \n  // Check if description has positive signals\n  const positiveSignalCount = config.positiveSignals.filter(sig => \n    titleLower.includes(sig) || descLower.includes(sig)\n  ).length;\n  \n  return hasRelevantTitle || positiveSignalCount >= 2;\n}\n\nfunction isJuniorLevel(job) {\n  const titleLower = job.job_title.toLowerCase();\n  const descLower = (job.description || '').toLowerCase();\n  \n  // Check for explicit junior indicators in title (high confidence include)\n  const hasJuniorTitle = config.juniorIndicators.some(ind => titleLower.includes(ind));\n  \n  // Check for junior indicators in description\n  const hasJuniorDesc = config.juniorIndicators.some(ind => descLower.includes(ind));\n  \n  // Check for senior exclusions in title (high confidence exclude)\n  const hasSeniorTitle = config.seniorExclusions.some(exc => titleLower.includes(exc));\n  \n  // Check for high experience requirements in description\n  const hasHighExp = config.experienceExclusions.some(exc => descLower.includes(exc));\n  \n  // Decision logic:\n  // 1. If title explicitly says junior/entry level → INCLUDE\n  if (hasJuniorTitle) return true;\n  \n  // 2. If title says senior/lead/etc → EXCLUDE\n  if (hasSeniorTitle) return false;\n  \n  // 3. If description mentions high experience → EXCLUDE\n  if (hasHighExp) return false;\n  \n  // 4. If description mentions junior/early career → INCLUDE\n  if (hasJuniorDesc) return true;\n  \n  // 5. For roles without explicit seniority, include if no senior indicators\n  // This captures \"DevOps Engineer\" roles that don't specify level\n  return !hasSeniorTitle && !hasHighExp;\n}\n\nfunction isValidLocation(job) {\n  const locationLower = (job.location || '').toLowerCase();\n  return !config.excludedLocations.some(loc => locationLower.includes(loc));\n}\n\nfunction isNotExcludedRole(job) {\n  const titleLower = job.job_title.toLowerCase();\n  return !config.excludedRoles.some(role => titleLower.includes(role));\n}\n\n// =============================================================================\n// APPLY FILTERS\n// =============================================================================\n\nconst filteredJobs = allJobs.filter(job => {\n  // Basic validation\n  if (!job.job_title || !job.job_url) return false;\n  \n  // Apply all filters\n  if (!isRelevantRole(job)) return false;\n  if (!isJuniorLevel(job)) return false;\n  if (!isValidLocation(job)) return false;\n  if (!isNotExcludedRole(job)) return false;\n  \n  return true;\n});\n\nconsole.log(`[${staticData.filterVersion || 'v1.0'}] Filtered to ${filteredJobs.length} relevant entry-level jobs`);\n\n// Update run stats for health monitoring\nif (!staticData.runStats) {\n  staticData.runStats = { jobsLast24h: 0, lastHeartbeat: null };\n}\nstaticData.runStats.jobsLast24h += filteredJobs.length;\n\nreturn [{ json: { \n  jobs: filteredJobs, \n  totalRaw: allJobs.length,\n  totalFiltered: filteredJobs.length,\n  errors: staticData.sourceErrors || [],\n  filter_version: staticData.filterVersion || 'v1.0'\n} }];"
      },
      "id": "filter-jobs",
      "name": "Filter Jobs",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1980, 400]
    },
    {
      "parameters": {
        "jsCode": "// =============================================================================\n// DEDUPLICATE JOBS - Using persistent hash storage\n// =============================================================================\nconst staticData = $getWorkflowStaticData('global');\n\n// Initialize hash storage if not exists\nif (!staticData.seenJobHashes) {\n  staticData.seenJobHashes = {};\n}\n\n// Clean up old hashes (older than 30 days) to prevent unbounded growth\nconst thirtyDaysAgo = Date.now() - (30 * 24 * 60 * 60 * 1000);\nlet cleanedCount = 0;\nfor (const hash in staticData.seenJobHashes) {\n  if (staticData.seenJobHashes[hash] < thirtyDaysAgo) {\n    delete staticData.seenJobHashes[hash];\n    cleanedCount++;\n  }\n}\nif (cleanedCount > 0) {\n  console.log(`Cleaned up ${cleanedCount} old job hashes`);\n}\n\nconst input = $input.first().json;\nconst jobs = input.jobs || [];\nconst newJobs = [];\n\n// Simple hash function for deduplication\nfunction simpleHash(str) {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash; // Convert to 32bit integer\n  }\n  return hash.toString(16);\n}\n\nfor (const job of jobs) {\n  // Create unique identifier from normalized fields\n  const identifier = [\n    job.job_title.toLowerCase().trim(),\n    job.company.toLowerCase().trim(),\n    job.location.toLowerCase().trim()\n  ].join('|');\n  \n  const hash = simpleHash(identifier);\n  \n  // Check if we've seen this job before\n  if (!staticData.seenJobHashes[hash]) {\n    staticData.seenJobHashes[hash] = Date.now();\n    newJobs.push(job);\n  }\n}\n\nconsole.log(`Found ${newJobs.length} new jobs (${jobs.length - newJobs.length} duplicates filtered)`);\nconsole.log(`Total hashes in storage: ${Object.keys(staticData.seenJobHashes).length}`);\n\nreturn [{ json: { \n  jobs: newJobs, \n  totalRaw: input.totalRaw,\n  totalFiltered: input.totalFiltered,\n  totalNew: newJobs.length,\n  errors: input.errors\n} }];"
      },
      "id": "deduplicate-jobs",
      "name": "Deduplicate Jobs",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2200, 400]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "has-new-jobs",
              "leftValue": "={{ $json.totalNew }}",
              "rightValue": 0,
              "operator": {
                "type": "number",
                "operation": "gt"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-has-jobs",
      "name": "Has New Jobs?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [2420, 400]
    },
    {
      "parameters": {
        "jsCode": "// =============================================================================\n// FORMAT TELEGRAM MESSAGES - Smart Batching with Adaptive Formats\n// =============================================================================\n// Check kill switch for notifications\nconst enableNotifications = $env.ENABLE_NOTIFICATIONS !== 'false';\n\nif (!enableNotifications) {\n  console.log('Notifications DISABLED via ENABLE_NOTIFICATIONS - skipping Telegram');\n  return [];\n}\n\nconst input = $input.first().json;\nconst jobs = input.jobs || [];\nconst messages = [];\nconst MAX_MESSAGE_LENGTH = 4000; // Leave buffer under 4096 limit\n\nif (jobs.length === 0) {\n  return [];\n}\n\n// Escape special characters for Telegram MarkdownV2\nfunction esc(text) {\n  if (!text) return '';\n  return String(text)\n    .replace(/\\\\/g, '\\\\\\\\')\n    .replace(/\\_/g, '\\\\_')\n    .replace(/\\*/g, '\\\\*')\n    .replace(/\\[/g, '\\\\[')\n    .replace(/\\]/g, '\\\\]')\n    .replace(/\\(/g, '\\\\(')\n    .replace(/\\)/g, '\\\\)')\n    .replace(/\\~/g, '\\\\~')\n    .replace(/\\`/g, '\\\\`')\n    .replace(/\\>/g, '\\\\>')\n    .replace(/\\#/g, '\\\\#')\n    .replace(/\\+/g, '\\\\+')\n    .replace(/\\-/g, '\\\\-')\n    .replace(/\\=/g, '\\\\=')\n    .replace(/\\|/g, '\\\\|')\n    .replace(/\\{/g, '\\\\{')\n    .replace(/\\}/g, '\\\\}')\n    .replace(/\\./g, '\\\\.')\n    .replace(/\\!/g, '\\\\!');\n}\n\n// Shorten location for compact formats\nfunction shortLoc(loc) {\n  if (!loc) return '';\n  return loc.replace(/,.*$/, '').replace('Remote', 'Remote').substring(0, 20);\n}\n\n// Shorten title for ultra-compact\nfunction shortTitle(title) {\n  if (!title) return 'Job';\n  return title.replace(/Engineer/gi, 'Eng').replace(/Junior/gi, 'Jr').replace(/Entry Level/gi, 'Entry').substring(0, 25);\n}\n\n// =============================================================================\n// FORMAT DEFINITIONS\n// =============================================================================\n\n// FORMAT 2: DETAILED (~350 chars per job) - for <= 10 jobs\nfunction formatDetailed(job, index) {\n  return `*${esc(job.job_title)}*\\n` +\n    `\\uD83C\\uDFE2 Company: ${esc(job.company)}\\n` +\n    `\\uD83D\\uDCCD Location: ${esc(job.location)}\\n` +\n    `\\uD83D\\uDD27 Source: ${esc(job.source)}\\n` +\n    `\\uD83D\\uDD17 [Apply Here](${job.job_url})\\n` +\n    `\\\\-\\\\-\\\\-\\\\-\\\\-\\\\-\\\\-\\\\-\\\\-\\\\-\\\\-\\\\-\\\\-\\\\-\\\\-`;\n}\n\n// FORMAT 1: COMPACT (~200 chars per job) - for <= 25 jobs\nfunction formatCompact(job, index) {\n  return `${index + 1}\\\\. ${esc(job.job_title)}\\n` +\n    `   \\uD83D\\uDCCD ${esc(job.company)} \\u2022 ${esc(shortLoc(job.location))} \\u2022 [Apply](${job.job_url})`;\n}\n\n// FORMAT 3: ULTRA-COMPACT (~100 chars per job) - for > 25 jobs\nfunction formatUltraCompact(job, index) {\n  return `\\u2022 [${esc(shortTitle(job.job_title))}](${job.job_url}) @ ${esc(job.company)} \\\\(${esc(shortLoc(job.location))}\\\\)`;\n}\n\n// =============================================================================\n// SMART FORMAT SELECTION\n// =============================================================================\nconst jobCount = jobs.length;\nlet formatFn, headerEmoji, charsPerJob;\n\nif (jobCount <= 10) {\n  formatFn = formatDetailed;\n  headerEmoji = '\\uD83D\\uDCE2';\n  charsPerJob = 350;\n  console.log(`Using DETAILED format for ${jobCount} jobs`);\n} else if (jobCount <= 25) {\n  formatFn = formatCompact;\n  headerEmoji = '\\uD83D\\uDE80';\n  charsPerJob = 200;\n  console.log(`Using COMPACT format for ${jobCount} jobs`);\n} else {\n  formatFn = formatUltraCompact;\n  headerEmoji = '\\uD83D\\uDE80';\n  charsPerJob = 100;\n  console.log(`Using ULTRA-COMPACT format for ${jobCount} jobs`);\n}\n\n// =============================================================================\n// BUILD MESSAGES - Fill to ~4000 chars before creating new message\n// =============================================================================\nlet currentMessage = `${headerEmoji} *${jobCount} New DevOps Jobs Found*\\n\\n`;\nlet jobsInCurrentMessage = 0;\nlet messageIndex = 1;\n\nfor (let i = 0; i < jobs.length; i++) {\n  const job = jobs[i];\n  const formattedJob = formatFn(job, jobsInCurrentMessage);\n  \n  // Check if adding this job would exceed message length\n  if (currentMessage.length + formattedJob.length + 10 > MAX_MESSAGE_LENGTH) {\n    // Save current message and start new one\n    messages.push({ text: currentMessage.trim() });\n    messageIndex++;\n    currentMessage = `${headerEmoji} *Jobs \\\\(continued ${messageIndex}\\\\)*\\n\\n`;\n    jobsInCurrentMessage = 0;\n  }\n  \n  currentMessage += formattedJob + '\\n\\n';\n  jobsInCurrentMessage++;\n}\n\n// Add the last message with summary\nif (jobsInCurrentMessage > 0) {\n  const summary = `\\n\\\\-\\\\-\\\\-\\\\-\\\\-\\\\-\\\\-\\\\-\\\\-\\\\-\\\\-\\\\-\\\\-\\\\-\\\\-\\\\-\\\\-\\\\-\\\\-\\\\-\\n` +\n    `\\uD83D\\uDCCA *Summary*\\n` +\n    `Total scraped: ${input.totalRaw || 0}\\n` +\n    `After filtering: ${input.totalFiltered || 0}\\n` +\n    `New jobs: ${input.totalNew || 0}`;\n  \n  currentMessage += summary;\n  messages.push({ text: currentMessage.trim() });\n}\n\nconsole.log(`Created ${messages.length} Telegram messages for ${jobs.length} jobs`);\n\nreturn messages.map(msg => ({ json: msg }));"
      },
      "id": "format-telegram",
      "name": "Format Telegram Messages",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2640, 300]
    },
    {
      "parameters": {
        "operation": "sendMessage",
        "chatId": "={{ $env.TELEGRAM_CHAT_ID }}",
        "text": "={{ $json.text }}",
        "additionalFields": {
          "parse_mode": "MarkdownV2",
          "disable_web_page_preview": true
        }
      },
      "id": "telegram-send",
      "name": "Send to Telegram",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [2860, 300],
      "credentials": {
        "telegramApi": {
          "id": "telegram-bot-cred",
          "name": "Telegram Bot"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "amount": 2,
        "unit": "seconds"
      },
      "id": "telegram-delay",
      "name": "Message Delay",
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [3080, 300]
    },
    {
      "parameters": {
        "jsCode": "// Log completion\nconsole.log('Telegram messages sent successfully');\nreturn $input.all();"
      },
      "id": "log-complete",
      "name": "Log Complete",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3300, 300]
    },
    {
      "parameters": {
        "jsCode": "// =============================================================================\n// LOG NO NEW JOBS - Execution summary when no alerts needed\n// =============================================================================\nconst input = $input.first().json;\n\nconsole.log('='.repeat(60));\nconsole.log('Job Alert Workflow Summary');\nconsole.log('='.repeat(60));\nconsole.log(`Total jobs scraped: ${input.totalRaw || 0}`);\nconsole.log(`After filtering: ${input.totalFiltered || 0}`);\nconsole.log(`New jobs found: ${input.totalNew || 0}`);\nconsole.log('Result: No new jobs to send');\n\nif (input.errors && input.errors.length > 0) {\n  console.log('');\n  console.log('Errors encountered:');\n  input.errors.forEach(err => {\n    console.log(`  - ${err.source?.company || 'unknown'}: ${err.error}`);\n  });\n}\n\nconsole.log('='.repeat(60));\n\nreturn [{ json: { status: 'completed', newJobs: 0, timestamp: new Date().toISOString() } }];"
      },
      "id": "log-no-jobs",
      "name": "Log No New Jobs",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2640, 500]
    },
    {
      "parameters": {
        "jsCode": "// =============================================================================\n// AGGREGATOR APIs - JSearch and SerpApi (Layer B)\n// =============================================================================\nconst staticData = $getWorkflowStaticData('global');\nconst enableAggregators = $env.ENABLE_AGGREGATOR_APIS !== 'false';\n\nif (!enableAggregators) {\n  console.log('Aggregator APIs DISABLED via ENABLE_AGGREGATOR_APIS');\n  return [{ json: { aggregatorJobs: [], skipped: true } }];\n}\n\n// Initialize API usage tracking\nif (!staticData.apiUsage) {\n  staticData.apiUsage = {\n    jsearch: { used_this_month: 0, limit: 500, is_exhausted: false },\n    serpapi: { used_this_month: 0, limit: 100, is_exhausted: false }\n  };\n}\n\n// Check for monthly reset\nconst now = new Date();\nconst resetDate = staticData.apiUsage.jsearch.reset_date;\nif (!resetDate || new Date(resetDate).getMonth() !== now.getMonth()) {\n  staticData.apiUsage.jsearch.used_this_month = 0;\n  staticData.apiUsage.jsearch.is_exhausted = false;\n  staticData.apiUsage.serpapi.used_this_month = 0;\n  staticData.apiUsage.serpapi.is_exhausted = false;\n  const nextMonth = new Date(now.getFullYear(), now.getMonth() + 1, 1);\n  staticData.apiUsage.jsearch.reset_date = nextMonth.toISOString();\n  staticData.apiUsage.serpapi.reset_date = nextMonth.toISOString();\n}\n\n// Search queries for aggregator APIs\nconst searchQueries = [\n  'junior devops engineer',\n  'entry level cloud engineer',\n  'associate platform engineer',\n  'junior MLOps engineer',\n  'entry level kubernetes engineer'\n];\n\n// Select one query per run to conserve quota\nconst query = searchQueries[Math.floor(Math.random() * searchQueries.length)];\n\nconsole.log(`Aggregator API query: ${query}`);\nconsole.log(`JSearch usage: ${staticData.apiUsage.jsearch.used_this_month}/${staticData.apiUsage.jsearch.limit}`);\nconsole.log(`SerpApi usage: ${staticData.apiUsage.serpapi.used_this_month}/${staticData.apiUsage.serpapi.limit}`);\n\nreturn [{ json: { query, apiUsage: staticData.apiUsage } }];"
      },
      "id": "aggregator-init",
      "name": "Initialize Aggregator APIs",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1760, 400]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "=https://jsearch.p.rapidapi.com/search?query={{ encodeURIComponent($json.query) }}&page=1&num_pages=1",
        "options": {
          "timeout": 30000
        },
        "headerParameters": {
          "parameters": [
            {
              "name": "X-RapidAPI-Key",
              "value": "={{ $env.RAPIDAPI_KEY }}"
            },
            {
              "name": "X-RapidAPI-Host",
              "value": "jsearch.p.rapidapi.com"
            }
          ]
        }
      },
      "id": "jsearch-handler",
      "name": "JSearch API",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1980, 400],
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// =============================================================================\n// JSEARCH PARSER - Parse results from JSearch API\n// =============================================================================\nconst staticData = $getWorkflowStaticData('global');\nconst data = $input.first().json;\nconst jobs = [];\n\n// Update usage tracking\nstaticData.apiUsage.jsearch.used_this_month++;\nstaticData.apiUsage.jsearch.last_used = new Date().toISOString();\n\n// Check if we hit rate limit or quota\nif (data.error || data.message?.includes('rate limit') || data.message?.includes('quota')) {\n  console.log('JSearch rate limited or quota exceeded');\n  staticData.apiUsage.jsearch.is_exhausted = true;\n  return [{ json: { jobs: [], error: 'rate_limited', fallback: true } }];\n}\n\ntry {\n  const results = data.data || [];\n  \n  for (const job of results) {\n    if (job.job_title && job.employer_name) {\n      jobs.push({\n        job_title: (job.job_title || '').trim(),\n        company: (job.employer_name || '').trim(),\n        location: [job.job_city, job.job_state, job.job_country].filter(Boolean).join(', ') || 'Unknown',\n        job_url: job.job_apply_link || job.job_google_link || '',\n        source: 'JSearch',\n        ats: 'aggregator',\n        board: 'jsearch',\n        description: (job.job_description || '').toLowerCase().substring(0, 1000),\n        posted_at: job.job_posted_at_datetime_utc || new Date().toISOString(),\n        job_id: job.job_id || '',\n        discovery_layer: 'aggregator_api',\n        discovered_via: 'jsearch',\n        filter_version: staticData.filterVersion || 'v1.0'\n      });\n    }\n  }\n  \n  console.log(`JSearch returned ${jobs.length} jobs`);\n} catch (err) {\n  console.log(`JSearch parse error: ${err.message}`);\n}\n\n// Add jobs to collected jobs\nstaticData.collectedJobs = staticData.collectedJobs || [];\nstaticData.collectedJobs.push(...jobs);\n\nreturn [{ json: { jobs, count: jobs.length } }];"
      },
      "id": "parse-jsearch",
      "name": "Parse JSearch",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2200, 400],
      "continueOnFail": true
    }
  ],
  "connections": {
    "Bi-Hourly Trigger": {
      "main": [
        [
          {
            "node": "Load Source Configuration",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Source Configuration": {
      "main": [
        [
          {
            "node": "Iterate Sources",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Iterate Sources": {
      "main": [
        [
          {
            "node": "Rate Limit Wait",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Initialize Aggregator APIs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Initialize Aggregator APIs": {
      "main": [
        [
          {
            "node": "JSearch API",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "JSearch API": {
      "main": [
        [
          {
            "node": "Parse JSearch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse JSearch": {
      "main": [
        [
          {
            "node": "Filter Jobs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Rate Limit Wait": {
      "main": [
        [
          {
            "node": "Route by ATS Type",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route by ATS Type": {
      "main": [
        [
          {
            "node": "Greenhouse Handler",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Lever Handler",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Ashby Handler",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "SmartRecruiters Handler",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Workable Handler",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "RemoteOK Handler",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Unsupported ATS Handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Greenhouse Handler": {
      "main": [
        [
          {
            "node": "Parse Greenhouse",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Lever Handler": {
      "main": [
        [
          {
            "node": "Parse Lever",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ashby Handler": {
      "main": [
        [
          {
            "node": "Parse Ashby",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SmartRecruiters Handler": {
      "main": [
        [
          {
            "node": "Parse SmartRecruiters",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Workable Handler": {
      "main": [
        [
          {
            "node": "Parse Workable",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "RemoteOK Handler": {
      "main": [
        [
          {
            "node": "Parse RemoteOK",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Unsupported ATS Handler": {
      "main": [
        [
          {
            "node": "Collect Jobs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Greenhouse": {
      "main": [
        [
          {
            "node": "Collect Jobs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Lever": {
      "main": [
        [
          {
            "node": "Collect Jobs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Ashby": {
      "main": [
        [
          {
            "node": "Collect Jobs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse SmartRecruiters": {
      "main": [
        [
          {
            "node": "Collect Jobs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Workable": {
      "main": [
        [
          {
            "node": "Collect Jobs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse RemoteOK": {
      "main": [
        [
          {
            "node": "Collect Jobs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Collect Jobs": {
      "main": [
        [
          {
            "node": "Iterate Sources",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Filter Jobs": {
      "main": [
        [
          {
            "node": "Deduplicate Jobs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Deduplicate Jobs": {
      "main": [
        [
          {
            "node": "Has New Jobs?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has New Jobs?": {
      "main": [
        [
          {
            "node": "Format Telegram Messages",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Log No New Jobs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Telegram Messages": {
      "main": [
        [
          {
            "node": "Send to Telegram",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send to Telegram": {
      "main": [
        [
          {
            "node": "Message Delay",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Message Delay": {
      "main": [
        [
          {
            "node": "Log Complete",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "saveExecutionProgress": true,
    "errorWorkflow": "",
    "timezone": "UTC"
  },
  "staticData": null,
  "tags": [
    {
      "name": "job-alerts"
    },
    {
      "name": "devops"
    },
    {
      "name": "dynamic"
    }
  ],
  "triggerCount": 1,
  "active": false
}
